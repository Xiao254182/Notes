## 23.使用GitLab+Jenkins+k8s建立CICD解决方案

#### 一.系统环境

本笔记只讲解怎么部署，因此所有系统都部署在同一台服务器上(192.168.100.11)

CI/CD解决方案架构图：

![](https://github.com/Xiao254182/Notes/blob/master/img/23/1.png)

CI/CD解决方案架构图描述：

程序员写好代码之后，向gitlab代码仓库提交代码，gitlab检测到变化之后，触发CI/CD服务器Jenkins，CI/CD服务器-Jenkins构建镜像，镜像构建好之后推送到registry镜像仓库，最后使用新的镜像在Kubernetes(k8s)环境部署。

#### 二.前言

DevOps是一种将开发（Development）和运维（Operations）相结合的软件开发方法论。它通过自动化和持续交付的方式，将软件开发、测试和部署等环节紧密集成，以提高效率和产品质量。在本篇博客中，我们将介绍如何使用GitLab、Jenkins和Kubernetes(k8s)来构建一个完整的CI/CD解决方案。

使用GitLab、Jenkins和Kubernetes(k8s)来构建CI/CD解决方案的前提是已经有一套可以正常运行的Kubernetes集群，关于Kubernetes(k8s)集群的安装部署可以查看[kubeadm搭建k8s高可用集群(三主两从一VIP)](https://github.com/Xiao254182/Notes/blob/master/13.kubeadm%E6%90%AD%E5%BB%BAk8s%E9%AB%98%E5%8F%AF%E7%94%A8%E9%9B%86%E7%BE%A4(%E4%B8%89%E4%B8%BB%E4%B8%A4%E4%BB%8E%E4%B8%80VIP).md)

#### 三.DevOps简介

DevOps通过打破开发和运维之间的壁垒，促进了更紧密的合作和快速响应变化的能力。它强调团队间的协作、自动化和持续改进。通过引入DevOps实践，组织可以更快地交付软件，并确保高质量的发布。

#### 四.CI/CD简介

CI/CD代表持续集成（Continuous Integration）和持续交付（Continuous Delivery）。持续集成是指团队成员将其工作频繁地集成到共享存储库中，并进行自动化构建和测试，以减少集成问题。持续交付是指将应用程序更频繁地交付给用户，以便快速获得反馈并提供新功能。本次使用的CI/CD工具为Jenkins。

#### 五.安装并配置docker参数

1.所有节点关闭防火墙

```shell
systemctl stop firewalld && systemctl disable firewalld
```

2.所有节点关闭selinux

```shell
#临时关闭selinux
setenforce 0

#永久关闭selinux
sed -i 's/^SELINUX=enforcing$/SELINUX=permissive/' /etc/selinux/config
```

3.所有节点关闭交换分区

```shell
#临时关闭所有的交换分区
swapoff -a

#永久关闭所有的交换分区
sed -i '/swap/s/^\(.*\)$/#\1/g' /etc/fstab
```

4.所有节点进行时间同步

```shell
#安裝同步时间命令
yum install ntpdate -y

#同步时间
ntpdate cn.pool.ntp.org

#设置定时任务每五分钟同步一次时间
echo "*/5 * * * * root /usr/sbin/ntpdate cn.pool.ntp.org &>/dev/null" >> /etc/crontab
```

5.所有节点安装需要的一些命令

- 添加centos源并将下载地址更换为阿里云地址

```shell
#添加centos源
curl -o /etc/yum.repos.d/CentOS-Base.repo https://mirrors.aliyun.com/repo/Centos-7.repo

#将下载地址更换为阿里云地址
sed -i -e '/mirrors.cloud.aliyuncs.com/d' -e '/mirrors.aliyuncs.com/d' /etc/yum.repos.d/CentOS-Base.repo
```

- 添加epel扩展源

```shell
curl -o /etc/yum.repos.d/epel.repo http://mirrors.aliyun.com/repo/epel-7.repo
```

- 清除缓存并重新加载源缓存

```shell
yum clean all && yum makecache
```

- 升级yum并安装一些会用到的命令

```shell
yum -y update && yum -y install vim wget jq net-tools yum-utils git tree
```

6.部署 docker

```shell
#添加阿里云的docker镜像地址
[root@localhost ~]# sudo yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo

#更新缓存，只处理新添加的yum源缓存
[root@localhost ~]# yum makecache fast

#部署docker，默认安装26.1.4版本
[root@localhost ~]# yum install -y docker-ce docker-ce-cli containerd.io

#查看安装docker版本
[root@localhost ~]# docker --version(或者使用docker version)
Docker version 26.1.4, build 5650f9b

#加载docker配置,启动docker服务并设置开机自启
[root@localhost ~]# systemctl daemon-reload && systemctl start docker && systemctl enable docker
```

#### 六.为docker存储单独挂载一个磁盘

1.在服务器上添加一个磁盘

```shell
[root@localhost ~]# lsblk 
NAME            MAJ:MIN RM  SIZE RO TYPE MOUNTPOINT
sda               8:0    0   20G  0 disk 
├─sda1            8:1    0    1G  0 part /boot
└─sda2            8:2    0   19G  0 part 
  ├─centos-root 253:0    0   17G  0 lvm  /
  └─centos-swap 253:1    0    2G  0 lvm  [SWAP]
sdb               8:16   0  100G  0 disk 
sr0              11:0    1 1024M  0 rom 
```

2.直接分区

```shell
[root@localhost ~]# fdisk /dev/sdb 
欢迎使用 fdisk (util-linux 2.23.2)。

更改将停留在内存中，直到您决定将更改写入磁盘。
使用写入命令前请三思。

Device does not contain a recognized partition table
使用磁盘标识符 0x72636d07 创建新的 DOS 磁盘标签。

命令(输入 m 获取帮助)：n
Partition type:
   p   primary (0 primary, 0 extended, 4 free)
   e   extended
Select (default p): 
Using default response p
分区号 (1-4，默认 1)：
起始 扇区 (2048-209715199，默认为 2048)：
将使用默认值 2048
Last 扇区, +扇区 or +size{K,M,G} (2048-209715199，默认为 209715199)：
将使用默认值 209715199
分区 1 已设置为 Linux 类型，大小设为 100 GiB

命令(输入 m 获取帮助)：w
The partition table has been altered!

Calling ioctl() to re-read partition table.
正在同步磁盘。
[root@localhost ~]# lsblk 
NAME            MAJ:MIN RM  SIZE RO TYPE MOUNTPOINT
sda               8:0    0   20G  0 disk 
├─sda1            8:1    0    1G  0 part /boot
└─sda2            8:2    0   19G  0 part 
  ├─centos-root 253:0    0   17G  0 lvm  /
  └─centos-swap 253:1    0    2G  0 lvm  [SWAP]
sdb               8:16   0  100G  0 disk 
└─sdb1            8:17   0  100G  0 part 
sr0              11:0    1 1024M  0 rom 
```

- 输入 `n` 创建新分区
- 选择 `p` 创建主分区
- 按回车使用默认分区号
- 再次回车使用默认的起始扇区
- 最后回车使用全部磁盘空间
- 输入 `w` 保存并退出

3.格式化分区

```shell
[root@localhost ~]# mkfs.ext4 /dev/sdb1
mke2fs 1.42.9 (28-Dec-2013)
文件系统标签=
OS type: Linux
块大小=4096 (log=2)
分块大小=4096 (log=2)
Stride=0 blocks, Stripe width=0 blocks
6553600 inodes, 26214144 blocks
1310707 blocks (5.00%) reserved for the super user
第一个数据块=0
Maximum filesystem blocks=2174746624
800 block groups
32768 blocks per group, 32768 fragments per group
8192 inodes per group
Superblock backups stored on blocks: 
        32768, 98304, 163840, 229376, 294912, 819200, 884736, 1605632, 2654208, 
        4096000, 7962624, 11239424, 20480000, 23887872

Allocating group tables: 完成                            
正在写入inode表: 完成                            
Creating journal (32768 blocks): 完成
Writing superblocks and filesystem accounting information: 完成   
```

4.创建挂载目录并挂载磁盘

```shell
[root@localhost ~]# mkdir /data
[root@localhost ~]# mount /dev/sdb1 /data
[root@localhost ~]# df -h
文件系统                 容量  已用  可用 已用% 挂载点
devtmpfs                 4.8G     0  4.8G    0% /dev
tmpfs                    4.8G     0  4.8G    0% /dev/shm
tmpfs                    4.8G   12M  4.8G    1% /run
tmpfs                    4.8G     0  4.8G    0% /sys/fs/cgroup
/dev/mapper/centos-root   17G  2.0G   16G   12% /
/dev/sda1               1014M  151M  864M   15% /boot
tmpfs                    982M     0  982M    0% /run/user/0
/dev/sdb1                 99G   61M   94G    1% /data
```

5.设置开机自动挂载

```shell
[root@localhost ~]# vim /etc/fstab 
[root@localhost ~]# cat /etc/fstab 

#
# /etc/fstab
# Created by anaconda on Fri Mar  8 22:34:21 2024
#
# Accessible filesystems, by reference, are maintained under '/dev/disk'
# See man pages fstab(5), findfs(8), mount(8) and/or blkid(8) for more info
#
/dev/mapper/centos-root /                       xfs     defaults        0 0
UUID=41e03c4f-3b94-4070-8dfb-19d7b292f843 /boot                   xfs     defaults        0 0
/dev/mapper/centos-swap swap                    swap    defaults        0 0
/dev/sdb1  /data  ext4  defaults  0 0
```

6.修改Docker默认镜像和容器存储位置

Docker默认安装的情况下，会使用 `/var/lib/docker/` 目录作为存储目录，用以存放拉取的镜像和创建的容器等。不过一般生产环境下都是直接为docker的存储专门挂载一个盘的，因为需要修改docker的存储位置。

（1）在docker启动前（未开始使用前）修改存储位置

这里有两种修改方式，按照docker版本来的

`--graph` 选项是 Docker 早期版本中用于指定 Docker 存储位置的选项。在 Docker 17.05 版本之前，`--graph` 是一个有效的命令行参数。

从 **Docker 17.05** 开始，`--graph` 被标记为已废弃（deprecated），并被替换为 `--data-root` 参数。功能相同，都是用来指定 Docker 的存储位置。

所以，以下是关键点：

- Docker **17.05** 之前：使用 `--graph`或`-g`参数指定存储位置。

  编辑docker配置文件`/usr/lib/systemd/system/docker.service`

  ```json
  ExecStart=/usr/bin/dockerd --graph /data/docker
  ```

  ```shell
  # reload配置文件 
  systemctl daemon-reload 
   
  # 重启docker
  systemctl restart docker.service
  ```

- Docker **17.05 及以后**：改用 `--data-root`。

  如果你使用的是较新版本的 Docker，应使用 `--data-root` 来配置存储位置。配置方式可以通过编辑 Docker     配置文件（通常是 `/etc/docker/daemon.json`）来完成，例如：

  ```json
  {
    "data-root": "/data/docker"
  }
  ```

  然后重启 Docker 服务：

  ```shell
  systemctl restart docker
  ```

此时，你会在你选择的docker存储路径中看到docker相关的内容，而且容器成功存储在我们想要的存储目录

#### 七.使用registry搭建镜像仓库

创建registry容器，registry镜像生成容器作为私有仓库，-p 5000:5000做端口映射，物理机端口5000:容器端口5000，注意：registry的数据卷为：VOLUME [/var/lib/registry]，不能是其他的
-v /data/registry:/var/lib/registry数据卷挂载，物理机目录/data/registry:容器目录/var/lib/registry。

```shell
[root@localhost ~]# docker run -d --name registry -p 5000:5000 --restart=always -v /data/registry:/var/lib/registry swr.cn-north-4.myhuaweicloud.com/ddn-k8s/docker.io/registry:latest
b10d929c4fb69b775ca09bbde49a444aafed3fa538099d8aa590ad46f40b481c
```

现在registry镜像仓库就搭建好了。

```shell
[root@localhost ~]# docker ps | grep registry
b10d929c4fb6   swr.cn-north-4.myhuaweicloud.com/ddn-k8s/docker.io/registry:latest   "/entrypoint.sh /etc…"   32 seconds ago   Up 31 seconds   0.0.0.0:5000->5000/tcp, :::5000->5000/tcp   registry
```

此时镜像仓库下还没有任何文件

```shell
[root@localhost ~]# ls /data/registry/
```

修改docker启动脚本，--insecure-registry=192.168.100.11:5000是镜像仓库的地址， 我们使用registry搭建镜像仓库，添加了--insecure-registry=192.168.100.11:5000参数之后，就可以使用http的方式拉取镜像，不然默认使用https的方式拉取镜像

```shell
[root@localhost data]# vim /usr/lib/systemd/system/docker.service

[root@localhost data]# cat !$ | grep ExecStart
cat /usr/lib/systemd/system/docker.service | grep ExecStart
ExecStart=/usr/bin/dockerd --insecure-registry=192.168.100.11:5000 -H fd:// --containerd=/run/containerd/containerd.sock

# 重新加载配置文件，重启docker。
[root@localhost data]# systemctl daemon-reload && systemctl restart docker

# 查看状态docker信息发现修改参数成功
[root@localhost data]# docker info | grep -A3 "Insecure Registries"
 Insecure Registries:
  192.168.100.11:5000
  127.0.0.0/8
 Registry Mirrors:
```

#### 八.安装部署gitlab代码仓库

1 创建gitlab容器

创建gitlab配置文件目录，日志目录，代码目录

```shell
[root@localhost ~]# mkdir -p /data/gitlab/etc /data/gitlab/log /data/gitlab/data   
```

给gitlab配置文件目录，日志目录，代码目录授予777权限

```shell
[root@localhost ~]# chmod 777 /data/gitlab/etc /data/gitlab/log /data/gitlab/data   
```

创建gitlab容器，使用--privileged=true参数，使container内的root拥有真正的root权限。否则，container内的root只是外部的一个普通用户权限。--privileged=true启动的容器，可以看到很多host上的设备，并且可以执行mount。甚至允许你在docker容器中启动docker容器。

-v指定数据卷，gitlab容器的配置文件，日志文件，数据文件也都存储到了物理机上，我们修改对应数据卷的内容，gitlab容器的相关内容也随之改变。-p指定端口映射。

```shell
[root@localhost ~]# docker run -dit --name=gitlab --restart=always -p 8443:443 -p 80:80 -p 222:22 -v /data/gitlab/etc:/etc/gitlab -v /data/gitlab/log:/var/log/gitlab -v /data/gitlab/data:/var/opt/gitlab --privileged=true swr.cn-north-4.myhuaweicloud.com/ddn-k8s/docker.io/twang2218/gitlab-ce-zh:latest
```

查看gitlab容器

```shell
[root@localhost ~]# docker ps | grep gitlab
9d79d6f0605d   swr.cn-north-4.myhuaweicloud.com/ddn-k8s/docker.io/twang2218/gitlab-ce-zh:latest   "/assets/wrapper"         4 seconds ago   Up 2 seconds (health: starting)   0.0.0.0:80->80/tcp, :::80->80/tcp, 0.0.0.0:222->22/tcp, :::222->22/tcp, 0.0.0.0:8443->443/tcp, :::8443->443/tcp   gitlab
```

现在gitlab配置文件目录，日志目录，代码目录都有相关文件了。

```shell
[root@localhost ~]# ls /data/gitlab/etc/
gitlab.rb            ssh_host_ecdsa_key      ssh_host_ed25519_key      ssh_host_rsa_key      trusted-certs
gitlab-secrets.json  ssh_host_ecdsa_key.pub  ssh_host_ed25519_key.pub  ssh_host_rsa_key.pub

[root@localhost ~]# ls /data/gitlab/log/
alertmanager    gitlab-rails      logrotate      postgres-exporter  reconfigure     sidekiq
gitaly          gitlab-shell      nginx          postgresql         redis           sshd
gitlab-monitor  gitlab-workhorse  node-exporter  prometheus         redis-exporter  unicorn

[root@localhost ~]# ls /data/gitlab/data/
alertmanager  git-data        gitlab-shell      node-exporter      public_attributes.json
backups       gitlab-ci       gitlab-workhorse  postgres-exporter  redis
bootstrapped  gitlab-monitor  logrotate         postgresql         trusted-certs-directory-hash
gitaly        gitlab-rails    nginx             prometheus
```

2 修改gitlab容器配置文件

注意先让gitlab容器运行一段时间，让其数据进行初始化，然后再停止gitlab容器，修改配置文件。

```shell
[root@etcd1 ~]# docker stop gitlab   
```

下面开始修改gitlab的配置文件。

修改/data/gitlab/etc/gitlab.rb，external_url指的是gitlab所在的机器IP，gitlab_ssh_host指定gitlab所在的机器IP，gitlab_shell_ssh_port指定ssh端口，因为我们把gitlab容器的22端口映射为了222，所以gitlab_shell_ssh_port为222。

```shell
[root@localhost ~]# docker stop gitlab 
gitlab

[root@localhost ~]# cat <<EOF >> /data/gitlab/etc/gitlab.rb
> external_url 'http://192.168.100.11'
> gitlab_rails['gitlab_ssh_host'] = '192.168.100.11'
> gitlab_rails['gitlab_shell_ssh_port'] = 222
> EOF

[root@localhost ~]# cat /data/gitlab/etc/gitlab.rb | egrep -v "^#" | egrep "external_url|gitlab_ssh_host|ssh_port"
external_url 'http://192.168.100.11'
gitlab_rails['gitlab_ssh_host'] = '192.168.100.11'
gitlab_rails['gitlab_shell_ssh_port'] = 222
```

修改/data/gitlab/data/gitlab-rails/etc/gitlab.yml，host指定gitlab所在的机器IP，端口为80，不使用https。

```shell
[root@localhost ~]# vim /data/gitlab/data/gitlab-rails/etc/gitlab.yml   

[root@localhost ~]# grep -A6 192.168.100.11 /data/gitlab/data/gitlab-rails/etc/gitlab.yml
    host: 192.168.100.11
    port: 80
    https: false
```

启动gitlab容器。

```shell
[root@localhost ~]# docker restart gitlab
gitlab
```

查看gitlab容器。

```shell
[root@localhost ~]# docker ps | grep gitlab
9d79d6f0605d   swr.cn-north-4.myhuaweicloud.com/ddn-k8s/docker.io/twang2218/gitlab-ce-zh:latest   "/assets/wrapper"         8 minutes ago    Up 11 seconds (health: starting)   0.0.0.0:80->80/tcp, :::80->80/tcp, 0.0.0.0:222->22/tcp, :::222->22/tcp, 0.0.0.0:8443->443/tcp, :::8443->443/tcp   gitlab
```

3 访问gitlab web界面

浏览器访问gitlab所在机器的IP地址和80端口，即可访问gitlab web界面 。

访问gitlab界面http://192.168.100.11，gitlab登录界面如下。

![](https://github.com/Xiao254182/Notes/blob/master/img/23/2.png)

点击修改密码(注意密码如果太简单会报错)，设置账号密码：账号为root，密码为：Abc12345。

登录gitlab之后，首页如下

![](https://github.com/Xiao254182/Notes/blob/master/img/23/3.png)

4 创建项目

点击创建一个项目。

![](https://github.com/Xiao254182/Notes/blob/master/img/23/4.png)

设置项目名称为：my-project，项目描述（可选），可见等级设置为公开，点击创建项目。

![](https://github.com/Xiao254182/Notes/blob/master/img/23/5.png)

选择SSH的方式拉取和推送代码，点击新建SSH公钥，否则无法通过SSH拉取和推送代码。

![](https://github.com/Xiao254182/Notes/blob/master/img/23/6.png)

需要粘贴SSH的公钥，现在去代码上传的机器上拿密钥。

![](https://github.com/Xiao254182/Notes/blob/master/img/23/7.png)

现在回到`192.168.100.11`机器，创建SSH密钥，复制公钥信息到Gitlab的密钥里。

现在还没有SSH密钥。

```shell
[root@localhost ~]# ls ~/.ssh/
ls: 无法访问/root/.ssh/: 没有那个文件或目录
```

生成密钥，-N ""表示提供一个新密语，密语为空。

```shell
[root@localhost ~]# ssh-keygen -N ""
Generating public/private rsa key pair.
Enter file in which to save the key (/root/.ssh/id_rsa): 
Created directory '/root/.ssh'.
Your identification has been saved in /root/.ssh/id_rsa.
Your public key has been saved in /root/.ssh/id_rsa.pub.
The key fingerprint is:
SHA256:MiJhMhyKbhmuAlJzXKdOf7o5p2JkmC/L5/oax9ifV7E root@localhost
The key's randomart image is:
+---[RSA 2048]----+
| .    . .        |
|+ .. . o         |
|=o= o o          |
|o=o+ o .    .    |
|o=. .o+ S .  o   |
|=  .o=oo o  E    |
|o   o++ .  .     |
|.  ..o=..+o      |
|    =Xo.*=       |
+----[SHA256]-----+
```

查看生成的密钥，id_rsa是私钥 ，id_rsa.pub是公钥。

```shell
[root@localhost ~]# ls ~/.ssh/
id_rsa  id_rsa.pub
```

查看公钥，并复制公钥信息到Gitlab的密钥里。

```shell
[root@localhost ~]# cat ~/.ssh/id_rsa.pub
ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQCZ+nqK4S7NIk8ohNDxQCwsIQdG4WjSiNbjFu3CZn7B/YGwf3owe8+Uu8eMhbiQbkeKNFWIWPWjsCrwnWIbaSH9U6dqlE/uIRTZeXOZ1ofBplWemVdv9puXsU3DcfWjKXyZyO85TZ9CF6LqUA+7ma+aWBKmPr6804W0HmXlElV/uLPiRFv7RzHkcNjCvPPGs2DkbZC+vVFnhxjs+QBe3IX1BmXzOs+EznuUjmkP1u7G6UsInhqSZBjs3H8jGHs0CHSm9I3M++BqYh6TQZUziOrm4LGkpnQNbDuY19S64d5GTPdlR3OKUAvYcdBPlPki73FGEBdtTFUcyPF1um33gqbv root@localhost
```

复制公钥信息到Gitlab的密钥里，点击添加密钥。

![](https://github.com/Xiao254182/Notes/blob/master/img/23/8.png)

添加密钥之后如下。

![](https://github.com/Xiao254182/Notes/blob/master/img/23/9.png)

5 创建Git版本库

点击项目--->您的项目，选择刚才创建的my-project项目

![](https://github.com/Xiao254182/Notes/blob/master/img/23/10.png)

根据命令行指令创建Git版本库。

```shell
# 安装Git
[root@localhost ~]# yum -y install git    

# --global表示Git 全局设置，设置用户名和邮箱。
[root@localhost ~]# git config --global user.name "Administrator"
[root@localhost ~]# git config --global user.email "admin@example.com"

# 把我们gitlab上的项目克隆下来。
[root@localhost ~]# git clone ssh://git@192.168.100.11:222/root/my-project.git
正克隆到 'my-project'...
The authenticity of host '[192.168.100.11]:222 ([192.168.100.11]:222)' can't be established.
ECDSA key fingerprint is SHA256:+XrN4S54C/uqkP33xtfimJpsZVAsgCCzVUNBAAqtOvQ.
ECDSA key fingerprint is MD5:6f:ef:96:35:ee:4c:53:c6:90:dc:35:74:87:f4:56:a9.
Are you sure you want to continue connecting (yes/no)? yes
Warning: Permanently added '[192.168.100.11]:222' (ECDSA) to the list of known hosts.
warning: 您似乎克隆了一个空版本库。

# 添加一条测试代码
[root@localhost ~]# cd my-project/
[root@localhost my-project]# echo "test" >> index.html

# 在Git 1.0 中，git push 默认会把你本地的所有分支都上传到远程， push.default 的值是‘matching’,git config --global push.default matching。到了git 2.0，git push默认是把当前分支上传到远程而不是所有本地分支，push.default 的值是‘simple’，这样比较保守也推荐这样，git config --global push.default simple。
[root@localhost my-project]# git config --global push.default matching
[root@localhost my-project]# git config --global push.default simple

# git add 命令可将该文件添加到暂存区。
[root@localhost my-project]# git add index.html

# 添加注释
[root@localhost my-project]# git commit -m "add index.html"
[master（根提交） d34bc31] add index.html
 1 file changed, 1 insertion(+)
 create mode 100644 index.html
 
# git push命令用于将本地分支的更新，推送到远程主机。
[root@localhost my-project]# git push 
Counting objects: 3, done.
Writing objects: 100% (3/3), 221 bytes | 0 bytes/s, done.
Total 3 (delta 0), reused 0 (delta 0)
To ssh://git@192.168.100.11:222/root/my-project.git
 * [new branch]      master -> master 
```

去gitlab界面上看文件是否推送过去，可以看到index.html被推送到gitlab代码仓库了。

![](https://github.com/Xiao254182/Notes/blob/master/img/23/11.png)

自此gitlab代码仓库配置完成

#### 九.安装部署CI/CD服务器jenkins

1 创建jenkins容器

创建jenkins数据卷所需要的目录，并把所有者和所属组改为1000。

```shell
[root@localhost ~]# mkdir /data/jenkins && chown 1000:1000 /data/jenkins

[root@localhost ~]# ll -d /data/jenkins/
drwxr-xr-x 2 1000 1000 4096 12月 26 19:58 /data/jenkins/
```

/data/jenkins的属主UID要改成1000的原因为：容器里是以jenkins用户的身份去读写数据，而在容器里 jenkins 的 uid 是 1000，可以看下此镜像的 Dockerfile 内容。

通过jenkins镜像的Dockerfile可以发现，用户UID和用户组GID为1000，HTTP端口为8080，代理端口为50000。

![](https://github.com/Xiao254182/Notes/blob/master/img/23/12.png)

创建jenkins容器。

- -dit: 在后台以交互模式运行容器，并分配一个伪终端。
- -p 8080:8080: 将主机的8080端口映射到容器的8080端口，允许通过主机的8080端口访问Jenkins的Web界面。
- -p 50000:50000: 将主机的50000端口映射到容器的50000端口，用于Jenkins的代理节点通信。
- --name jenkins: 指定容器的名称为"jenkins"。
- --privileged=true: 启用特权模式，允许容器内部的进程拥有更高级别的权限。
- --restart=always: 定义容器在退出或重启之后应该自动重新启动。
- -v /data/jenkins:/var/jenkins_home: 将主机上的"/data/jenkins"目录挂载到容器内部的"/var/jenkins_home"目录，用于持久化Jenkins数据。

```shell
[root@localhost ~]# docker run -dit -p 8080:8080 -p 50000:50000 --name jenkins --privileged=true --restart=always -v /data/jenkins:/var/jenkins_home swr.cn-north-4.myhuaweicloud.com/ddn-k8s/docker.io/jenkins/jenkins:lts
```

2 修改Jenkins配置文件

让jenkins容器运行一段时间之后，再访问jenkins web界面，浏览器访问:192.168.100.11:8080，即可访问jenkins的web界面：

![](https://github.com/Xiao254182/Notes/blob/master/img/23/13.png)

下面需要修改jenkins容器的配置文件，因为jenkins容器使用了数据卷：-v /data/jenkins:/var/jenkins_home，我们修改物理机/jenkins下面的文件，对应容器里的文件也就相应改变。

先停止容器，再修改配置文件。

```shell
[root@localhost ~]# docker stop jenkins
jenkins

[root@localhost ~]# docker ps -a | grep jenkins
502559a416b7   swr.cn-north-4.myhuaweicloud.com/ddn-k8s/docker.io/jenkins/jenkins:lts             "/usr/bin/tini -- /u…"   38 seconds ago   Exited (143) 6 seconds ago                                                                                                                     jenkins
```

查看/jenkins/hudson.model.UpdateCenter.xml内容。

```shell
[root@localhost ~]# ls /data/jenkins/
config.xml                     jenkins.telemetry.Correlator.xml  plugins     secret.key.not-so-secret  userContent
copy_reference_file.log        jobs                              queue.xml   secrets                   users
hudson.model.UpdateCenter.xml  nodeMonitors.xml                  secret.key  updates                   war

[root@localhost ~]# cat /data/jenkins/hudson.model.UpdateCenter.xml
<?xml version='1.1' encoding='UTF-8'?>
<sites>
  <site>
    <id>default</id>
    <url>https://updates.jenkins.io/update-center.json</url>
  </site>
</sites>
```

`https://updates.jenkins.io/update-center.json`这个插件地址为国外的地址，网络不好可能会无法下载插件，因此需要修改为国内的插件地址来提高安装jenkins插件的下载速度

`https://mirrors.tuna.tsinghua.edu.cn/jenkins/updates/update-center.json`下载的是始终是最新的插件，和旧版本的Jenkins是不兼容的，因此需要替换为`https://mirrors.tuna.tsinghua.edu.cn/jenkins/updates/dynamic-stable-VERSION/update-center.json`才能装到匹配的插件版本，其中`VERSION`是当前Jenkins的版本。如果不是LTS版本，则`dynamic-stable-VERSION`要换成`dynamic-VERSION`

```shell
[root@localhost ~]# vim /data/jenkins/hudson.model.UpdateCenter.xml

[root@localhost ~]# cat !$
cat /data/jenkins/hudson.model.UpdateCenter.xml
<?xml version='1.1' encoding='UTF-8'?>
<sites>
  <site>
    <id>default</id>
    <url>https://mirrors.tuna.tsinghua.edu.cn/jenkins/updates/dynamic-stable-2.462.1/update-center.json</url>
  </site>
</sites>
```

/data/jenkins/updates/default.json文件的connectionCheckUrl修改为："connectionCheckUrl":"http://www.baidu.com/" 。

```shell
[root@localhost ~]# ll /data/jenkins/updates/default.json -h
-rw-r--r-- 1 1000 1000 3.0M 12月 26 20:01 /data/jenkins/updates/default.json

[root@localhost ~]# sed -i 's/http:\/\/updates.jenkins-ci.org\/download/https:\/\/mirrors.tuna.tsinghua.edu.cn\/jenkins/g' /data/jenkins/updates/default.json && sed -i 's/www.google.com/www.baidu.com/g' /data/jenkins/updates/default.json
```

启动Jenkins。

```shell
[root@localhost ~]# docker restart jenkins
jenkins

[root@localhost ~]# docker ps | grep jenkins
502559a416b7   swr.cn-north-4.myhuaweicloud.com/ddn-k8s/docker.io/jenkins/jenkins:lts             "/usr/bin/tini -- /u…"   21 minutes ago   Up 11 seconds             0.0.0.0:8080->8080/tcp, :::8080->8080/tcp, 0.0.0.0:50000->50000/tcp, :::50000->50000/tcp                          jenkins
```

3 查看jenkins管理员密码并登录

刷新jenkins web页面，查看Jenkins需要的管理员密码。

jenkins管理员密码在/data/jenkins/secrets/initialAdminPassword文件，查看密码并把密码复制到jenkins页面

```shell
[root@localhost ~]# cat /data/jenkins/secrets/initialAdminPassword
91a622f42bc84ed498c2a5f2b3e0d04f
```

4 安装Jenkins插件

点击安装推荐的插件,现在插件就开始安装了。

![](https://github.com/Xiao254182/Notes/blob/master/img/23/14.png)

Jenkins插件安装完成之后，会出现创建管理员用户界面。

![](https://github.com/Xiao254182/Notes/blob/master/img/23/15.png)

创建管理员用户：用户名:`admin`密码:`admin`全名:`admin`电子邮箱地址:`admin@example.com`。点击保存并完成

实例配置：Jenkins URL 用于给各种Jenkins资源提供绝对路径链接的根地址，Jenkins URL:http://192.168.100.11:8080/，点击保存并完成。

![](https://github.com/Xiao254182/Notes/blob/master/img/23/16.png)

此时jenkins就安装完成了，点击开始使用。

jenkins主界面如下：

![](https://github.com/Xiao254182/Notes/blob/master/img/23/17.png)

jenkins需要连接我们物理机的docker，然后编译构建镜像，把镜像推送到registry仓库，所以jenkins需要安装docker插件，在jenkins主页依次点击manage jenkins-->Manage Plugins-->可选插件，搜索docker，选择 docker 和其所需的插件安装。

![](https://github.com/Xiao254182/Notes/blob/master/img/23/18.png)

![](https://github.com/Xiao254182/Notes/blob/master/img/23/19.png)

选中安装完成后重启jenkins（空闲时）。

![](https://github.com/Xiao254182/Notes/blob/master/img/23/20.png)

在Jenkins web页面重启jenkins太慢了，我们手动重启jenkins。

```shell
[root@localhost ~]# docker restart jenkins 
jenkins

[root@localhost ~]# docker ps | grep jenkins
502559a416b7   swr.cn-north-4.myhuaweicloud.com/ddn-k8s/docker.io/jenkins/jenkins:lts             "/usr/bin/tini -- /u…"   34 minutes ago      Up 9 seconds              0.0.0.0:8080->8080/tcp, :::8080->8080/tcp, 0.0.0.0:50000->50000/tcp, :::50000->50000/tcp                          jenkins
```

刷新jenkins页面重新登录，用户名:admin 密码:admin

![](https://github.com/Xiao254182/Notes/blob/master/img/23/21.png)

在jenkins主页依次点击系统管理-->插件管理-->已安装，搜索docker，发现 docker 插件和 docker-build-step插件已经安装好了。

![](https://github.com/Xiao254182/Notes/blob/master/img/23/22.png)

5 配置Jenkins连接docker

在首页依次点击系统管理-->节点管理-->configure Clouds，Add a new cloud选择Docker。

![](https://github.com/Xiao254182/Notes/blob/master/img/23/23.png)

添加docker节点

![](https://github.com/Xiao254182/Notes/blob/master/img/23/24.png)

![](https://github.com/Xiao254182/Notes/blob/master/img/23/25.png)

![](https://github.com/Xiao254182/Notes/blob/master/img/23/26.png)

添加docker节点就需要docker可以远程访问，因此需要启动Docker的远程访问功能，我们需要修改Docker守护进程的配置，让它监听一个TCP端口。默认情况下，Docker守护进程只监听UNIX套接字，这只允许本机访问。通过修改配置，我们可以让Docker守护进程监听一个TCP端口，从而实现远程访问

要修改Docker Daemon的监听地址，我们需要编辑Docker服务的启动文件。

```shell
[root@localhost ~]# vim /lib/systemd/system/docker.service 

[root@localhost ~]# cat !$ | grep ExecStart
cat /lib/systemd/system/docker.service | grep ExecStart
ExecStart=/usr/bin/dockerd -H tcp://0.0.0.0:2376 -H fd:// --containerd=/run/containerd/containerd.sock
```

重启docker服务，然后发现docker开启了一个端口

```shell
[root@localhost ~]# systemctl daemon-reload && systemctl restart docker
[root@localhost ~]# netstat -ntpl | grep dockerd
tcp6       0      0 :::2376                 :::*                    LISTEN      29788/dockerd 
```

Docker Host URI输入连接docker的地址，此处为：tcp://192.168.100.11:2376，再点击test connection，如果出现docker的版本号，则jenkins连接docker成功，最后保存即可。

![](https://github.com/Xiao254182/Notes/blob/master/img/23/27.png)

在首页点击系统管理-->系统配置，找到 Docker Builder，在docker URL里输入连接的docker地址：tcp://192.168.110.133:2376，点击 test connection，如果出现Connected to tcp://192.168.100.11:2376，这样说明jenkins和docker就关联起来了，最后点击保存。

![](https://github.com/Xiao254182/Notes/blob/master/img/23/28.png)

![](https://github.com/Xiao254182/Notes/blob/master/img/23/29.png)
此时jenkins就能连接docker了。

6 安全设置

gitlab要触发jenkins操作，需要做相关安全设置，首页依次点击系统管理-->全局安全配置-->授权策略，勾选"匿名用户具有可读权限"。

![](https://github.com/Xiao254182/Notes/blob/master/img/23/30.png)

gitlab 要触发 jenkins 的话，就必须要关闭跨站请求伪造保护，但是在Jenkins版本自2.2xx版本之后，在 web 界面里已经没法关闭了，因此我们在命令行里操作。

```shell
# 进入jenkins容器
[root@localhost ~]# docker exec -u root -it jenkins bash 

# /usr/local/bin/jenkins.sh脚本中的exec java -Duser.home参数如下，
root@502559a416b7:/# egrep "exec java -Duser.home=" /usr/local/bin/jenkins.sh
  exec java -Duser.home="$JENKINS_HOME" "${java_opts_array[@]}" -jar "${JENKINS_WAR}" "${jenkins_opts_array[@]}" "$@"

# 我们需要修改exec java -Duser.home的值
root@502559a416b7:/# sed -i '/exec java -Duser.home=/ s|exec java -Duser.home="$JENKINS_HOME" .*|exec java -Duser.home="$JENKINS_HOME" -Dhudson.security.csrf.GlobalCrumbIssuerConfiguration.DISABLE_CSRF_PROTECTION=true ${FUTURE_OPTS} "${java_opts_array[@]}" -jar ${JENKINS_WAR} "${jenkins_opts_array[@]}" "$@"|' /usr/local/bin/jenkins.sh

# 修改后，exec java -Duser.home的值如下：
root@502559a416b7:/# egrep "exec java -Duser.home=" /usr/local/bin/jenkins.sh
  exec java -Duser.home="$JENKINS_HOME" -Dhudson.security.csrf.GlobalCrumbIssuerConfiguration.DISABLE_CSRF_PROTECTION=true ${FUTURE_OPTS} "${java_opts_array[@]}" -jar ${JENKINS_WAR} "${jenkins_opts_array[@]}" "$@"

# 退出jenkins容器
root@502559a416b7:/# exit
exit
```

重启Jenkins，使配置文件生效。

```shell
[root@localhost ~]# docker restart jenkins
jenkins
[root@localhost ~]# docker ps | grep jenkins
502559a416b7   swr.cn-north-4.myhuaweicloud.com/ddn-k8s/docker.io/jenkins/jenkins:lts             "/usr/bin/tini -- /u…"   58 minutes ago      Up 7 seconds             0.0.0.0:8080->8080/tcp, :::8080->8080/tcp, 0.0.0.0:50000->50000/tcp, :::50000->50000/tcp                          jenkins
```

重启好jenkins之后，登录jenkins web界面。

首页依次点击系统管理-->全局安全配置，此时跨站请求伪造保护已经被关闭了。

![](https://github.com/Xiao254182/Notes/blob/master/img/23/31.png)

#### 九.使用kubeadm部署一主二从k8s集群

具体可参考此篇笔记[使用kubeadm部署一主二从k8s集群](https://github.com/Xiao254182/Notes/blob/master/13.kubeadm%E6%90%AD%E5%BB%BAk8s%E9%AB%98%E5%8F%AF%E7%94%A8%E9%9B%86%E7%BE%A4(%E4%B8%89%E4%B8%BB%E4%B8%A4%E4%BB%8E%E4%B8%80VIP).md)，本次只部署一个一主二从的集群

| IP             | 节点         |
| -------------- | ------------ |
| 192.168.100.12 | k8s-master-1 |
| 192.168.100.13 | k8s-worker-1 |
| 192.168.100.14 | k8s-worker-2 |

我们把镜像推送到registry镜像仓库之后，k8s集群的worker节点会向registry镜像仓库拉取镜像，默认使用https的方式从镜像仓库拉取镜像，需要在k8s的worker节点修改docker启动参数，添加--insecure-registry=192.168.100.11:5000，让其使用http的方式从registry镜像仓库拉取镜像

具体操作请查看（七.使用registry搭建镜像仓库）

#### 十. 配置Jenkins连接Kubernetes(k8s)集群

1.jenkins添加kubernetes plugin

![](https://github.com/Xiao254182/Notes/blob/master/img/23/32.png)

![](https://github.com/Xiao254182/Notes/blob/master/img/23/33.png)

2.与配置Jenkins连接docker的时候一样，在首页依次点击系统管理-->节点管理-->configure Clouds，Add a new cloud选择kubernets并添加

![](https://github.com/Xiao254182/Notes/blob/master/img/23/34.png)

3.填写云kubernetes配置内容

在Kubetnetes集群中创建SA帐号授权cluster-admin权限，并获取其token

```shell
[root@k8s-master-1 ~]# kubectl create sa jenkins
serviceaccount/jenkins created
[root@k8s-master-1 ~]# kubectl create clusterrolebinding jenkins --clusterrole cluster-admin --serviceaccount=default:jenkins
clusterrolebinding.rbac.authorization.k8s.io/jenkins created
[root@k8s-master-1 ~]# kubectl describe sa jenkins -n default
Name:                jenkins
Namespace:           default
Labels:              <none>
Annotations:         <none>
Image pull secrets:  <none>
Mountable secrets:   jenkins-token-xx9mv
Tokens:              jenkins-token-xx9mv
Events:              <none>
[root@k8s-master-1 ~]# kubectl describe secrets jenkins-token-xx9mv -n default
Name:         jenkins-token-xx9mv
Namespace:    default
Labels:       <none>
Annotations:  kubernetes.io/service-account.name: jenkins
              kubernetes.io/service-account.uid: 46575041-dc77-427c-8b18-154872daf147

Type:  kubernetes.io/service-account-token

Data
====
ca.crt:     1066 bytes
namespace:  7 bytes
token:      eyJhbGciOiJSUzI1NiIsImtpZCI6InlCTXNHdUJYTThQWHV1TkNpVkxSalZ1LU1jOHAwVmk5RFNhS2FLTjhQRDAifQ.eyJpc3MiOiJrdWJlcm5ldGVzL3NlcnZpY2VhY2NvdW50Iiwia3ViZXJuZXRlcy5pby9zZXJ2aWNlYWNjb3VudC9uYW1lc3BhY2UiOiJkZWZhdWx0Iiwia3ViZXJuZXRlcy5pby9zZXJ2aWNlYWNjb3VudC9zZWNyZXQubmFtZSI6ImplbmtpbnMtdG9rZW4teHg5bXYiLCJrdWJlcm5ldGVzLmlvL3NlcnZpY2VhY2NvdW50L3NlcnZpY2UtYWNjb3VudC5uYW1lIjoiamVua2lucyIsImt1YmVybmV0ZXMuaW8vc2VydmljZWFjY291bnQvc2VydmljZS1hY2NvdW50LnVpZCI6IjQ2NTc1MDQxLWRjNzctNDI3Yy04YjE4LTE1NDg3MmRhZjE0NyIsInN1YiI6InN5c3RlbTpzZXJ2aWNlYWNjb3VudDpkZWZhdWx0OmplbmtpbnMifQ.mFFipKb5GvC8NzAAOu9erbHhak-ZBJ4Dmi1nV_PODtmJNYRZTYdLYjd_7quwVN67_b58dExEGH-x1j_Mu9rble9y5KSAqG--qEKflNbGczrtzGuUyD_DP333dL94fZuRvsV34zQW1j-5IwYmKStjm7zkft_RC7ZI5oVItMiD0gIC9gjO-CLwKAeUp9NSvpYVNB5KZTJhFKjm7tL9CgqSNeg502LTPFs7MqpthJiGj1xY6P4gBDsDOhFwl73vCqGzUB4iZpTU0FHxOsFzuti3y1vBz3uacbPjQOGOnpzvR7PDaWQZNZIoZIOLJJ0hTepXEu_tSMDzyvdc78Z2SQB3sg
```

将上面的tonken添加到Jenkins的凭据，凭据类型必须为Secret text类型。

![](https://github.com/Xiao254182/Notes/blob/master/img/23/35.png)

![](https://github.com/Xiao254182/Notes/blob/master/img/23/36.png)

配置连接Kubernetes集群

![](https://github.com/Xiao254182/Notes/blob/master/img/23/37.png)

![](https://github.com/Xiao254182/Notes/blob/master/img/23/38.png)

连接测试成功，点击保存，自此，jenkins就可以远程连接k8s环境了。

jenkins需要把镜像部署到Kubernetes(k8s)集群，所以jenkins需要kubectl客户端工具和kubeconfig文件

我们先将刚刚创建的admin权限的用户导出为kubeconfig文件

```shell
[root@k8s-master-1 ~]# kubectl config view --raw > admin-kubeconfig.yaml  
```

现在回到Kubernetes(k8s)集群直接拷贝一个kubectl文件和kubeconfig文件到Jenkins所在服务器。

```shell
[root@k8s-master-1 ~]# scp /usr/bin/kubectl 192.168.100.11:/root
root@192.168.100.11's password: 
kubectl                                                                                                                                                                                                                                                   100%   38MB  34.5MB/s   00:01  
[root@k8s-master-1 ~]# scp admin-kubeconfig.yaml 192.168.100.11:/root
root@192.168.100.11's password: 
admin-kubeconfig.yaml                                                                                                                                                                                                                                     100% 5588     1.1MB/s   00:00    
```

把kubectl文件和kubeconfig文件拷贝到jenkins容器。

```shell
[root@localhost ~]# docker cp kubectl jenkins:/
Successfully copied 40.2MB to jenkins:/
[root@localhost ~]# docker cp admin-kubeconfig.yaml jenkins:/
Successfully copied 7.17kB to jenkins:/
```

以root身份进入jenkins容器。

```shell
[root@localhost ~]# docker exec -u root -it jenkins bash
```

连接k8s集群，查看k8s集群节点状态，可以看到Jenkins成功连接k8s集群

```shell
root@c9ac4dac1b4a:/# ls
admin-kubeconfig.yaml  bin  boot  dev  etc  home  kubectl  lib  lib64  media  mnt  opt  proc  root  run  sbin  srv  sys  tmp  usr  var
root@c9ac4dac1b4a:/# ./kubectl --kubeconfig=admin-kubeconfig.yaml get nodes
NAME           STATUS   ROLES                  AGE     VERSION
k8s-master-1   Ready    control-plane,master   7h14m   v1.20.0
k8s-worker-1   Ready    <none>                 7h13m   v1.20.0
k8s-worker-2   Ready    <none>                 7h13m   v1.20.0
```

#### 十一.创建jenkins项目

首页点击新建任务，任务名称可以自定义，选择构建一个自由风格的软件项目，点击确定。

![](https://github.com/Xiao254182/Notes/blob/master/img/23/39.png)

![](https://github.com/Xiao254182/Notes/blob/master/img/23/40.png)

配置构建触发器，这样gitlab就可以触发jenkins了，在构建触发器那里选中触发远程构建（例如，使用脚本），身份验证令牌自定义。

注意：链接 JENKINS_URL/job/devopsProject/build?token= TOKEN_NAME，这个链接用于 gitlab 在触发 jenkins 时用到的链接，我们这里，TOKEN_NAME 的值是connect，JENKINS_URL 是 192.168.100.11:8080，所以整个链接为：
http://192.168.100.11:8080/job/devopsProject/build?token=connect。

![](https://github.com/Xiao254182/Notes/blob/master/img/23/41.png)

当gitlab代码仓库内容变动之后，会去触发jenkins，所以需要增加构建步骤。

点击构建-->增加构建步骤，选择执行shell。

![](https://github.com/Xiao254182/Notes/blob/master/img/23/42.png)

程序员提交了代码到gitlab之后，jenkins需要重新拉取新代码，这时要先删除家目录下的旧代码，再拉取新代码，不然会报错。

对于jenkins容器来说，家目录就是/var/jenkins_home，

```shell
# 进入Jenkins容器
[root@localhost ~]# docker exec -it jenkins /bin/bash

# cd ~表示进入家目录
jenkins@c9ac4dac1b4a:/$ cd ~

# 可以看到家目录为/var/jenkins_home
jenkins@c9ac4dac1b4a:~$ pwd
/var/jenkins_home

jenkins@c9ac4dac1b4a:~$ exit
exit
```

在构建-->增加构建步骤-->执行shell里输入如下语句，意思为进入jenkins容器家目录，删除旧代码，拉取新代码。

```shell
cd ~
rm -rf my-project
git clone http://192.168.100.11/root/my-project.git
```

在构建-->增加构建步骤-->执行shell里输入如下语句。

![](https://github.com/Xiao254182/Notes/blob/master/img/23/43.png)

Jenkins把新代码拉取下来之后，需要进行编译，接下来继续增加构建步骤，这次类型选择Build/Publish Docker Image。

![](https://github.com/Xiao254182/Notes/blob/master/img/23/44.png)

Build/Publish Docker Image-->Directory for Dockerfile里填，jenkins拉取代码是放在家目录下，Dockerfile也在家目录/var/jenkins_home/my-project/下。

Cloud选择docker，使用docker编译Dockerfile。

Image填：`192.168.100.11:5000/devopsproject/nginx:${BUILD_NUMBER}`，表示把编译好的镜像推送到registry仓库，因为代码会不断更新，Dockerfile会被编译好多次，所以使用{BUILD_NUMBER}变量，让镜像不重复，本次代码变动主要是nginx，所以写为nginx:${BUILD_NUMBER}。

选中Push image，把镜像推送到镜像仓库。

![](https://github.com/Xiao254182/Notes/blob/master/img/23/45.png)

把新代码拉取下来，Dockerfile被编译好并推送到镜像仓库之后，需要把新镜像部署到k8s环境，接下来继续增加构建步骤，这次类型选择执行shell。

执行shell里输入如下语句，解释如下：

```shell
# 在devops命名空间里，替换deployment/nginx的镜像为192.168.100.11:5000/devopsproject/nginx:${BUILD_NUMBER}
kubectl set image deployment/nginx nginx="192.168.110.133:5000/devopsproject/nginx:${BUILD_NUMBER}" -n devops
```

![](https://github.com/Xiao254182/Notes/blob/master/img/23/46.png)

最后点击保存。

#### 十二.创建deployment

现在回到Kubernetes(k8s)集群，因为jenkins把新镜像部署到devops命名空间下，所以创建一个命名空间devops。

```shell
[root@k8scloude1 ~]# kubectl create namespace devops
namespace/devops created
```

在k8s中如果不写-n指定命名空间的话默认是default命名空间，但是每次切换命名空间有比较麻烦，因此我们可以安装kubens来切换当前命名空间,切换命名空间后,就无需每次都使用 -n 命令来指定命名空间了

```bash
# 下载
[root@k8s-master-1 ~]# curl -L https://github.com/ahmetb/kubectx/releases/download/v0.9.1/kubens -o /usr/bin/kubens
  % Total    % Received % Xferd  Average Speed   Time    Time     Time  Current
                                 Dload  Upload   Total   Spent    Left  Speed
  0     0    0     0    0     0      0      0 --:--:--  0:00:01 --:--:--     0
100  5555  100  5555    0     0   2155      0  0:00:02  0:00:02 --:--:--  493k

 
# 给予执行权限 
[root@k8s-master-1 ~]# chmod +x /usr/bin/kubens

# 列出当前所有的命名空间
[root@k8s-master-1 ~]# kubens 
default
devops
kube-node-lease
kube-public
kube-system
```

切换命名空间到devops。

```shell
[root@k8s-master-1 ~]# kubens devops
Context "kubernetes-admin@kubernetes" modified.
Active namespace is "devops".
```

现在没有deploy。

```shell
[root@k8s-master-1 ~]# kubectl get deploy
No resources found in devops namespace.
```

使用Nginx镜像创建一个deploy，配置文件如下：

功能为：创建一个名为"nginx"的Deployment对象，Pod副本数为1

```yaml
[root@k8s-master-1 ~]# vim nginx.yaml
[root@k8s-master-1 ~]# cat !$
cat nginx.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  labels:
    app: nginx
  name: nginx
spec:
  replicas: 1
  selector:
    matchLabels:
      app: nginx
  template:
    metadata:
      labels:
        app: nginx
    spec:
      terminationGracePeriodSeconds: 0
      containers:
      - image: swr.cn-north-4.myhuaweicloud.com/ddn-k8s/docker.io/nginx:1.27.1
        name: nginx
        imagePullPolicy: IfNotPresent
```

创建deploy。

```shell
[root@k8s-master-1 ~]# kubectl apply -f nginx.yaml
deployment.apps/nginx created
```

deployment创建成功。

```shell
[root@k8s-master-1 ~]# kubectl get pod,deploy
NAME                         READY   STATUS    RESTARTS   AGE
pod/nginx-548864f989-xbqv2   1/1     Running   0          17s

NAME                    READY   UP-TO-DATE   AVAILABLE   AGE
deployment.apps/nginx   1/1     1            1           17s
```

给deploy创建一个名为nginxsvc的svc，端口为80，svc类型为NodePort

```shell
[root@k8s-master-1 ~]# kubectl expose --name=nginx deploy nginx --port=80 --type=NodePort
service/nginx exposed
```

查看svc。

```shell
[root@k8s-master-1 ~]# kubectl get svc
NAME    TYPE       CLUSTER-IP       EXTERNAL-IP   PORT(S)        AGE
nginx   NodePort   10.107.234.223   <none>        80:30865/TCP   14s
```

测试一下是否可以访问(访问一个不存在的路径来查看nginx的版本是否是拉取的镜像的版本)

```shell
[root@k8s-master-1 ~]# curl 192.168.100.12:30865/1
<html>
<head><title>404 Not Found</title></head>
<body>
<center><h1>404 Not Found</h1></center>
<hr><center>nginx/1.27.1</center>
</body>
</html>
```

#### 十三.配置gitlab触发jenkins

接下来回到gitlab，配置gitlab触发jenkins。

gitlab首页依次点击管理区域-->设置-->Outbound requests，展开Outbound requests，勾选允许钩子和服务访问本地网络，保存修改，这样jenkins才能访问gitlab代码仓库。

![](https://github.com/Xiao254182/Notes/blob/master/img/23/47.png)

首页点击项目-->您的项目，点击进入my-project项目。

选择设置-->导入所有仓库。

![](https://github.com/Xiao254182/Notes/blob/master/img/23/48.png)

注意：链接 JENKINS_URL/job/devopsProject/build?token= TOKEN_NAME，这个链接用于 gitlab 在触发 jenkins 时用到的链接，我们这里，TOKEN_NAME 的值是connect，JENKINS_URL 是 192.168.100.11:8080，所以链接(URL)填入gitlab 触发 jenkins 时用到的链接：http://192.168.100.11:8080/job/devopsProject/build?token=connect

![](https://github.com/Xiao254182/Notes/blob/master/img/23/49.png)

点击增加Web钩子。

![](https://github.com/Xiao254182/Notes/blob/master/img/23/50.png)

Web钩子生成后进行测试，点击Test-->Push events。

![](https://github.com/Xiao254182/Notes/blob/master/img/23/51.png)

如果看到如下，则test成功，gitlab能触发jenkins了。

![](https://github.com/Xiao254182/Notes/blob/master/img/23/52.png)

自此整个DevOps环境就搭建成功了。

#### 十四.测试DevOps

DevOps环境搭建成功之后，我们需要来测试整个流程。

进入项目。

```shell
[root@localhost ~]# ls
my-project
[root@localhost ~]# cd my-project/
[root@localhost my-project]# ls
index.html
[root@localhost my-project]# cat index.html 
test
```

编写Dockerfile文件

```shell
[root@localhost my-project]# vim Dockerfile
[root@localhost my-project]# cat !$
cat Dockerfile
FROM swr.cn-north-4.myhuaweicloud.com/ddn-k8s/docker.io/nginx:1.27.1
COPY index.html /usr/share/nginx/html/
EXPOSE 80
CMD ["nginx", "-g","daemon off;"]
```

更新首页文件。

```shell
[root@localhost my-project]# echo "devops-test" > index.html 
[root@localhost my-project]# cat !$
cat index.html
devops-test
```

2 上传代码到gitlab

git add命令把Dockerfile和index.html添加到暂存区。

```shell
[root@localhost my-project]# git add .
```

添加注释。

```shell
[root@localhost my-project]# git commit -m 'devops-test'
[master dfa624c] devops-test
 2 files changed, 5 insertions(+), 1 deletion(-)
 create mode 100644 Dockerfile
```

git push命令用于将本地分支的更新，推送到远程主机。

```shell
[root@localhost my-project]# git push
Counting objects: 6, done.
Delta compression using up to 4 threads.
Compressing objects: 100% (3/3), done.
Writing objects: 100% (4/4), 433 bytes | 0 bytes/s, done.
Total 4 (delta 0), reused 0 (delta 0)
To ssh://git@192.168.100.11:222/root/my-project.git
   d34bc31..dfa624c  master -> master
```

去gitlab界面看文件是否推送成功，可以看到git push成功。

![](https://github.com/Xiao254182/Notes/blob/master/img/23/53.png)

3 Jenkins执行CI/CD(自动构建自动部署)流程

因为gitlab上的文件发生变动，jenkins会拉取gitlab上的文件，进行编译，然后上传新镜像到registry仓库，最后把新镜像部署到k8s环境。

此时镜像已经推送到镜像仓库

```shell
[root@k8s-master-1 ~]# curl http://192.168.100.11:5000/v2/_catalog
{"repositories":["devopsproject/nginx"]}
```

点击状态，可以发现已经构建成功。

![](https://github.com/Xiao254182/Notes/blob/master/img/23/54.png)

此时我们测试，发现内容就是我们上传的测试代码

```shell
[root@localhost ~]# curl 192.168.100.12:30865
devops-test
```

说明DEVOPS流程成功。
